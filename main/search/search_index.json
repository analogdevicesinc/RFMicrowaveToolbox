{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> <p></p> <p>ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release ADALM-PHASER Yes No ADI (2022a) Stingray ZCU102 Yes No ADI (2022a)"},{"location":"examples/","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.</p>"},{"location":"install/#simulation-models","title":"Simulation Models","text":"<p>The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks:</p> <ul> <li>DSP System Toolbox</li> <li>Signal Processing Toolbox</li> <li>Fixed-Point Designer</li> <li>(Optional) Simulink</li> </ul>"},{"location":"install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox\u2122</li> </ul> </li> </ul>"},{"location":"install/#hdl-generation-support","title":"HDL Generation Support","text":"<p>To leverage HDL-Coder and the reference designs with the toolbox requires the following components:</p> <ul> <li>Xilinx Vivado 2019.1</li> <li>Xilinx SDK 2019.1</li> <li>Simulink</li> <li>HDL-Coder\u2122</li> <li>HDL Coder\u2122 Support Package for Xilinx Zynq Platform</li> </ul>"},{"location":"install/#transceiver-toolbox-install","title":"Transceiver Toolbox Install","text":"<p>The Transceiver Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab:</p> <p></p> <p>Search for the toolbox:</p> <p></p> <p>Select Transceiver Toolbox from results:</p> <p></p> <p>Select add:</p> <p></p>"},{"location":"streaming/","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems.</p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\ndata = rx();\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by line 3 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release object\n</code></pre></p> <p>To provide a complete example we can do more advanced configuration like so to demonstrate property changes: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\nrx.SamplesPerFrame = 1024;\nrx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9];\ndataNCO1 = rx();\n\n% Update tunable property\nrx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9];\ndataNCO2 = rx();\n\n% Update non-tunable property\nrx.release();\nrx.SamplesPerFrame = 4096;\ndataLargerBuffer = rx();\n</code></pre></p>"},{"location":"streaming/#receiving-data","title":"Receiving Data","text":"<p>To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows:</p> <pre><code>rx = adi.DAQ2.Rx;\n</code></pre> <p>Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame.</p> <pre><code>rx.SamplesPerFrame = 1e6;\n</code></pre> <p>SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property.</p> <p>To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so:</p> <pre><code>data = rx(); % Operator method\ndata = rx.step(); % Step method\n</code></pre> <p>Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters:</p> <pre><code>rx.EnabledChannels = 1:16;\n</code></pre> <p>You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.</p>"},{"location":"streaming/#sending-data","title":"Sending Data","text":"<p>Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows:</p> <pre><code>tx = adi.AD9081.Tx;\n</code></pre> <p>Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data:</p> <pre><code>tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Operator method\ntx.step(tx_data); % Step method\n</code></pre> <p>However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs.</p> <p>Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows:</p> <pre><code>tx = adi.AD9081.Tx;\ntx.EnableCyclicBuffers = true;\ntx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Data will repeat forever\n</code></pre> <p>Once a vector is passed to the object with EnableCyclicBuffers set to true, the object will not accept future buffers unless first release or cleared.</p> <p>By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows:</p> <pre><code>rx.DataSource = 'DMA';\n</code></pre>"},{"location":"streaming/#dds","title":"DDS","text":"<p>Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property:</p> <pre><code>rx.DataSource = 'DDS';\n</code></pre> <p>Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows:</p> <pre><code>rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2]\nrx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1]\nrx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000]\n</code></pre> <p>Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).</p>"},{"location":"support/","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"_pages/","title":"Index","text":"<p>{% include 'header.tmpl' %}</p> <p> <p></p> <p>ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release ADALM-PHASER Yes No ADI (2022a) Stingray ZCU102 Yes No ADI (2022a)"},{"location":"_pages/examples/","title":"Examples","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/examples/#examples","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"_pages/install/","title":"Install","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/install/#installation","title":"Installation","text":""},{"location":"_pages/install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.</p>"},{"location":"_pages/install/#simulation-models","title":"Simulation Models","text":"<p>The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks:</p> <ul> <li>DSP System Toolbox</li> <li>Signal Processing Toolbox</li> <li>Fixed-Point Designer</li> <li>(Optional) Simulink</li> </ul>"},{"location":"_pages/install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox\u2122</li> </ul> </li> </ul>"},{"location":"_pages/install/#hdl-generation-support","title":"HDL Generation Support","text":"<p>To leverage HDL-Coder and the reference designs with the toolbox requires the following components:</p> <ul> <li>Xilinx Vivado 2019.1</li> <li>Xilinx SDK 2019.1</li> <li>Simulink</li> <li>HDL-Coder\u2122</li> <li>HDL Coder\u2122 Support Package for Xilinx Zynq Platform</li> </ul>"},{"location":"_pages/install/#transceiver-toolbox-install","title":"Transceiver Toolbox Install","text":"<p>The Transceiver Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"_pages/install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab:</p> <p></p> <p>Search for the toolbox:</p> <p></p> <p>Select Transceiver Toolbox from results:</p> <p></p> <p>Select add:</p> <p></p>"},{"location":"_pages/streaming/","title":"Streaming","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/streaming/#receiving-and-sending-data","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems.</p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"_pages/streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\ndata = rx();\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by line 3 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release object\n</code></pre></p> <p>To provide a complete example we can do more advanced configuration like so to demonstrate property changes: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\nrx.SamplesPerFrame = 1024;\nrx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9];\ndataNCO1 = rx();\n\n% Update tunable property\nrx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9];\ndataNCO2 = rx();\n\n% Update non-tunable property\nrx.release();\nrx.SamplesPerFrame = 4096;\ndataLargerBuffer = rx();\n</code></pre></p>"},{"location":"_pages/streaming/#receiving-data","title":"Receiving Data","text":"<p>To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows:</p> <pre><code>rx = adi.DAQ2.Rx;\n</code></pre> <p>Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame.</p> <pre><code>rx.SamplesPerFrame = 1e6;\n</code></pre> <p>SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property.</p> <p>To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so:</p> <pre><code>data = rx(); % Operator method\ndata = rx.step(); % Step method\n</code></pre> <p>Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters:</p> <pre><code>rx.EnabledChannels = 1:16;\n</code></pre> <p>You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.</p>"},{"location":"_pages/streaming/#sending-data","title":"Sending Data","text":"<p>Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows:</p> <pre><code>tx = adi.AD9081.Tx;\n</code></pre> <p>Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data:</p> <pre><code>tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Operator method\ntx.step(tx_data); % Step method\n</code></pre> <p>However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs.</p> <p>Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows:</p> <pre><code>tx = adi.AD9081.Tx;\ntx.EnableCyclicBuffers = true;\ntx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Data will repeat forever\n</code></pre> <p>Once a vector is passed to the object with EnableCyclicBuffers set to true, the object will not accept future buffers unless first release or cleared.</p> <p>By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows:</p> <pre><code>rx.DataSource = 'DMA';\n</code></pre>"},{"location":"_pages/streaming/#dds","title":"DDS","text":"<p>Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property:</p> <pre><code>rx.DataSource = 'DDS';\n</code></pre> <p>Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows:</p> <pre><code>rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2]\nrx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1]\nrx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000]\n</code></pre> <p>Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).</p>"},{"location":"_pages/support/","title":"Support","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/support/#support","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"sysobjects/adi.Phaser/","title":"adi.Phaser","text":"The adi.Phaser system object is an API to control the    ADALM-PHASER X/Ku Band Beamforming Developer Platform.     rx = adi.Phaser;    rx = adi.Phaser('uri','ip:ip:192.168.2.1'); Stingray X/Ku Band Beamforming Developer Platform Wiki Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.Phaser\ndev = adi.Phaser(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnablePLL + <p>Enable onboard PLL which is the main LO source. This controls V_CTRL_1</p> EnableTxPLL + <p>Enable PLL to feed the Tx LO. This controls V_CTRL_2</p> NumADAR1000s + <p></p> Mode + <p>Mode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of value 'Rx', 'Tx', or 'disabled' to set the modes.</p> LNABiasOutEnable + <p>Enable output of LNA bias DAC. LNABiasOutEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOn + <p>External Bias for External LNAs. LNABiasOn is an array where each element addresses individual ADAR1000's.</p> BeamMemEnable + <p>Enable beam memory. BeamMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACEnable + <p>Enable PA and LNA bias DACs. BiasDACEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACMode + <p>External Amplifier Bias Control. BiasDACMode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'On' or 'Off' to set the modes.</p> BiasMemEnable + <p>Enable bias memory. BiasMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonMemEnable + <p>CommonMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonRxBeamState + <p>Static Rx Beam Position Load. CommonRxBeamState is an array where each element addresses individual ADAR1000's.</p> CommonTxBeamState + <p>Static Tx Beam Position Load. CommonTxBeamState is an array where each element addresses individual ADAR1000's.</p> ExternalTRPin + <p>Select Tx/Rx output driver. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'Pos' or 'Neg' to set the modes.</p> ExternalTRPolarity + <p>Controls Sense of Tx/Rx Switch Driver Output. ExternalTRPolarity is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOff + <p>External Bias for External LNAs. LNABiasOff is an array where each element addresses individual ADAR1000's.</p> PolState + <p>Control for External Polarity Switch Drivers. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> PolSwitchEnable + <p>Enables Switch Driver for External Polarization Switch. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxLNABiasCurrent + <p>Set LNA bias current. RxLNABiasCurrent is an array where each element addresses individual ADAR1000's.</p> RxLNAEnable + <p>Enables Rx LNA. RxLNAEnable is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> RxToTxDelay1 + <p>LNA Bias off to TR Switch Delay. RxToTxDelay1 is an array where each element addresses individual ADAR1000's.</p> RxToTxDelay2 + <p>TR Switch to PA Bias on Delay. RxToTxDelay2 is an array where each element addresses individual ADAR1000's.</p> RxVGAEnable + <p>Enable Rx Channel VGAs. RxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxVGABiasCurrentVM + <p>Apply Rx bias current. RxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> RxVMEnable + <p>Enable Rx Channel Vector Modulators. RxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> SequencerEnable + <p>Enable sequencer. Sequencer is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TRSwitchEnable + <p>Enables Switch Driver for External Tx/Rx Switch. TRSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxPABiasCurrent + <p>Set Tx driver bias current. TxPABiasCurrent is an array where each element addresses individual ADAR1000's.</p> TxPAEnable + <p>Enables the Tx channel drivers. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> TxToRxDelay1 + <p>PA Bias off to TR Switch Delay. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.</p> TxToRxDelay2 + <p>TR Switch to LNA Bias on Delay. TxToRxDelay2 is an array where each element addresses individual ADAR1000's.</p> TxVGAEnable + <p>Enable Tx Channel VGAs. TxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxVGABiasCurrentVM + <p>Apply Tx bias current. TxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> TxVMEnable + <p>Enable Tx Channel Vector Modulators. TxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxRxSwitchControl + <p>Set source of control for Rx and Tx switching. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'spi' or 'external' to set the modes.</p> DetectorEnable + <p>DetectorEnable is an array where each element addresses each channel of each ADAR1000.</p> DetectorPower + <p>DetectorPower is an array where each element addresses each channel of each ADAR1000.</p> PABiasOff + <p>Apply bias off to external PA. PABiasOff is an array where each element addresses each channel of each ADAR1000.</p> PABiasOn + <p>Apply bias on to external PA. PABiasOn is an array where each element addresses each channel of each ADAR1000.</p> RxAttn + <p>Attenuate Rx channels. RxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> RxBeamState + <p>Load Rx Position. RxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxPowerDown + <p>Power down Rx channels. RxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> RxGain + <p>Apply gain to Rx channels. RxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> RxPhase + <p>Apply phase to Rx channels. RxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxAttn + <p>Attenuate Tx channels. TxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> TxBeamState + <p>Load Tx Position. TxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxPowerDown + <p>Power down Tx channels. TxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> TxGain + <p>Apply gain to Tx channels. TxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> TxPhase + <p>Apply phase to Tx channels. TxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxSequencerStart + <p>RxSequencerStart Rx Sequencer Start RxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> RxSequencerStop + <p>RxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStart + <p>TxSequencerStart Tx Sequencer Start TxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStop + <p>TxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> Temp + <p>Get temperature of X-band Development Platform.</p> TargetFrequency + <p>ADAR1000 target frequency</p> ElementSpacing + <p>ADAR1000 element spacing</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.Phaser/uri is inherited from superclass matlabshared.libiio.base</p> channelCount + <p>Number of enabled channelsHelp for adi.Phaser/channelCount is inherited from superclass matlabshared.libiio.base</p> DataTimeout + <p>Timeout for I/O operations (in seconds) 0 = non-blocking (or default context timeout) Inf = infiniteHelp for adi.Phaser/DataTimeout is inherited from superclass matlabshared.libiio.base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> Frequency + <p>Set output frequency of synthesizer in Hz. When the synthesizer is ramping this is the start frequencyHelp for adi.Phaser/Frequency is inherited from superclass adi.internal.ADF4159</p> FrequencyDeviationRange + <p>Set upper bound on frequency ramp from Frequency property in Hz. This is only applicable when RampMode is not set to \"disabled\"Help for adi.Phaser/FrequencyDeviationRange is inherited from superclass adi.internal.ADF4159</p> FrequencyDeviationStep + <p>Set step size in Hz of synthesizer ramp. This is only applicable when RampMode is not set to \"disabled\".Help for adi.Phaser/FrequencyDeviationStep is inherited from superclass adi.internal.ADF4159</p> FrequencyDeviationTime + <p>Set time in uSeconds to reach ramp peak value. This is only applicable when RampMode is not set to \"disabled\"Help for adi.Phaser/FrequencyDeviationTime is inherited from superclass adi.internal.ADF4159</p> RampMode + <p>Set ramp waveform. Options are: - \"disabled\" - \"continuous_sawtooth\" - \"continuous_triangular\" - \"single_sawtooth_burst\" - \"single_ramp_burst\"Help for adi.Phaser/RampMode is inherited from superclass adi.internal.ADF4159</p> Powerdown + <p>When true output will be disabled. Writing to this value will also update all settings of deviceHelp for adi.Phaser/Powerdown is inherited from superclass adi.internal.ADF4159</p> DelayStartWord + <p>Set start delay of each ramp in PFD or PFD*CLK1 clock cycles. This is a 12-bit numberHelp for adi.Phaser/DelayStartWord is inherited from superclass adi.internal.ADF4159</p> DelayClockSource + <p>Set clock use to determine ramp delay. Options are: - \"PFD\" - \"PFD*CLK1\"Help for adi.Phaser/DelayClockSource is inherited from superclass adi.internal.ADF4159</p> DelayStartEnable + <p>Enable delaying of ramp signal at start of first ramp generationHelp for adi.Phaser/DelayStartEnable is inherited from superclass adi.internal.ADF4159</p> RampDelayEnable + <p>Enable delaying of ramp signal at start of each ramp generationHelp for adi.Phaser/RampDelayEnable is inherited from superclass adi.internal.ADF4159</p> TriggerDelayEnable + <p>Enable ramp start delay when controlled by external triggerHelp for adi.Phaser/TriggerDelayEnable is inherited from superclass adi.internal.ADF4159</p> TriggerEnable + <p>Allow for use of external trigger on TX Data pin to start rampHelp for adi.Phaser/TriggerEnable is inherited from superclass adi.internal.ADF4159</p> SingleFullTriangleEnable + <p>Enable sending of single full triangular wave. This is applicable when RampMode is in \"single_ramp_burst\"Help for adi.Phaser/SingleFullTriangleEnable is inherited from superclass adi.internal.ADF4159</p> BurstCount + <p></p> CounterInt + <p></p> DMAGateingMode + <p>0 - none, 1 - rx_only, 2 - tx_only, 3 - rx_tx</p> Enable + <p></p> EnableMode + <p>1 - rx_only, 2 - tx_only, 3 - rx_tx</p> FrameLength + <p></p> Secondary + <p></p> SyncTerminalType + <p></p> TxDPoff + <p></p> TxDPon + <p></p> TxOff + <p></p> TxOn + <p></p> TxVCOoff + <p></p> TxVCOon + <p></p> RxDPoff + <p></p> RxDPon + <p></p> RxOff + <p></p> RxOn + <p></p> RxVCOoff + <p></p> RxVCOon + <p></p> Example Usage <pre><code>%% Configure device\ntx = adi.Phaser;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.Stingray/","title":"adi.Stingray","text":"The adi.Stingray system object is an API to control the    Stingray X/Ku Band Beamforming Developer Platform.     rx = adi.Stingray;    rx = adi.Stingray('uri','ip:ip:192.168.2.1'); Stingray X/Ku Band Beamforming Developer Platform Wiki Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.Stingray\ndev = adi.Stingray(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. NumADAR1000s + <p></p> Mode + <p>Mode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of value 'Rx', 'Tx', or 'disabled' to set the modes.</p> LNABiasOutEnable + <p>Enable output of LNA bias DAC. LNABiasOutEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOn + <p>External Bias for External LNAs. LNABiasOn is an array where each element addresses individual ADAR1000's.</p> BeamMemEnable + <p>Enable beam memory. BeamMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACEnable + <p>Enable PA and LNA bias DACs. BiasDACEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACMode + <p>External Amplifier Bias Control. BiasDACMode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'On' or 'Off' to set the modes.</p> BiasMemEnable + <p>Enable bias memory. BiasMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonMemEnable + <p>CommonMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonRxBeamState + <p>Static Rx Beam Position Load. CommonRxBeamState is an array where each element addresses individual ADAR1000's.</p> CommonTxBeamState + <p>Static Tx Beam Position Load. CommonTxBeamState is an array where each element addresses individual ADAR1000's.</p> ExternalTRPin + <p>Select Tx/Rx output driver. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'Pos' or 'Neg' to set the modes.</p> ExternalTRPolarity + <p>Controls Sense of Tx/Rx Switch Driver Output. ExternalTRPolarity is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOff + <p>External Bias for External LNAs. LNABiasOff is an array where each element addresses individual ADAR1000's.</p> PolState + <p>Control for External Polarity Switch Drivers. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> PolSwitchEnable + <p>Enables Switch Driver for External Polarization Switch. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxLNABiasCurrent + <p>Set LNA bias current. RxLNABiasCurrent is an array where each element addresses individual ADAR1000's.</p> RxLNAEnable + <p>Enables Rx LNA. RxLNAEnable is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> RxToTxDelay1 + <p>LNA Bias off to TR Switch Delay. RxToTxDelay1 is an array where each element addresses individual ADAR1000's.</p> RxToTxDelay2 + <p>TR Switch to PA Bias on Delay. RxToTxDelay2 is an array where each element addresses individual ADAR1000's.</p> RxVGAEnable + <p>Enable Rx Channel VGAs. RxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxVGABiasCurrentVM + <p>Apply Rx bias current. RxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> RxVMEnable + <p>Enable Rx Channel Vector Modulators. RxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> SequencerEnable + <p>Enable sequencer. Sequencer is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TRSwitchEnable + <p>Enables Switch Driver for External Tx/Rx Switch. TRSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxPABiasCurrent + <p>Set Tx driver bias current. TxPABiasCurrent is an array where each element addresses individual ADAR1000's.</p> TxPAEnable + <p>Enables the Tx channel drivers. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> TxToRxDelay1 + <p>PA Bias off to TR Switch Delay. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.</p> TxToRxDelay2 + <p>TR Switch to LNA Bias on Delay. TxToRxDelay2 is an array where each element addresses individual ADAR1000's.</p> TxVGAEnable + <p>Enable Tx Channel VGAs. TxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxVGABiasCurrentVM + <p>Apply Tx bias current. TxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> TxVMEnable + <p>Enable Tx Channel Vector Modulators. TxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxRxSwitchControl + <p>Set source of control for Rx and Tx switching. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'spi' or 'external' to set the modes.</p> DetectorEnable + <p>DetectorEnable is an array where each element addresses each channel of each ADAR1000.</p> DetectorPower + <p>DetectorPower is an array where each element addresses each channel of each ADAR1000.</p> PABiasOff + <p>Apply bias off to external PA. PABiasOff is an array where each element addresses each channel of each ADAR1000.</p> PABiasOn + <p>Apply bias on to external PA. PABiasOn is an array where each element addresses each channel of each ADAR1000.</p> RxAttn + <p>Attenuate Rx channels. RxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> RxBeamState + <p>Load Rx Position. RxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxPowerDown + <p>Power down Rx channels. RxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> RxGain + <p>Apply gain to Rx channels. RxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> RxPhase + <p>Apply phase to Rx channels. RxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxAttn + <p>Attenuate Tx channels. TxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> TxBeamState + <p>Load Tx Position. TxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxPowerDown + <p>Power down Tx channels. TxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> TxGain + <p>Apply gain to Tx channels. TxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> TxPhase + <p>Apply phase to Tx channels. TxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxSequencerStart + <p>RxSequencerStart Rx Sequencer Start RxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> RxSequencerStop + <p>RxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStart + <p>TxSequencerStart Tx Sequencer Start TxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStop + <p>TxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> Temp + <p>Get temperature of X-band Development Platform.</p> TargetFrequency + <p>ADAR1000 target frequency</p> ElementSpacing + <p>ADAR1000 element spacing</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.Stingray/uri is inherited from superclass matlabshared.libiio.base</p> channelCount + <p>Number of enabled channelsHelp for adi.Stingray/channelCount is inherited from superclass matlabshared.libiio.base</p> DataTimeout + <p>Timeout for I/O operations (in seconds) 0 = non-blocking (or default context timeout) Inf = infiniteHelp for adi.Stingray/DataTimeout is inherited from superclass matlabshared.libiio.base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerUpDown + <p></p> Ctrl5V + <p></p> PAOn + <p></p> TXRX0 + <p></p> TXRX1 + <p></p> TXRX2 + <p></p> TXRX3 + <p></p> PllOutputSel + <p></p> RxGainMode + <p></p> ADF4371Name + <p></p> ADF4371Frequency + <p></p> ADF4371Phase + <p></p> MUXOutEnable + <p></p> BurstCount + <p></p> CounterInt + <p></p> DMAGateingMode + <p>0 - none, 1 - rx_only, 2 - tx_only, 3 - rx_tx</p> Enable + <p></p> EnableMode + <p>1 - rx_only, 2 - tx_only, 3 - rx_tx</p> FrameLength + <p></p> Secondary + <p></p> SyncTerminalType + <p></p> TxDPoff + <p></p> TxDPon + <p></p> TxOff + <p></p> TxOn + <p></p> TxVCOoff + <p></p> TxVCOon + <p></p> RxDPoff + <p></p> RxDPon + <p></p> RxOff + <p></p> RxOn + <p></p> RxVCOoff + <p></p> RxVCOon + <p></p> LTC2314RFPower + <p></p> Example Usage <pre><code>%% Configure device\ntx = adi.Stingray;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"}]}