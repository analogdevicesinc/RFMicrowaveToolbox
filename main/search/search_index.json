{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> <p></p> <p>ADI maintains a set of tools to model, interface, and target with ADI's beamformers and microwave devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release ADALM-PHASER NA Yes No ADI (2021b) Stingray ZCU102 Yes No ADI (2021b)"},{"location":"examples/","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.</p>"},{"location":"install/#simulation-models","title":"Simulation Models","text":"<p>The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks:</p> <ul> <li>DSP System Toolbox</li> <li>Signal Processing Toolbox</li> <li>(Optional) Simulink</li> </ul>"},{"location":"install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox\u2122</li> </ul> </li> </ul>"},{"location":"install/#rf-and-microwave-toolbox-install","title":"RF and Microwave Toolbox Install","text":"<p>The RF and Microwave Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing RF and Microwave Toolbox check the Release Page to check for the latest supported version of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab:</p> <p></p> <p>Search for the toolbox:</p> <p></p> <p>Select RF and Microwave Toolbox from results:</p> <p></p> <p>Select add:</p> <p></p>"},{"location":"streaming/","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all libiio-based systems.</p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up an AD9361 receiver and the Stingray class in an X-band development kit using an Ethernet/IP backend where the address of the target system is 192.168.2.1: <pre><code>uri = 'ip:192.168.1.211';\n\nrx = adi.AD9081.Rx;\nrx.uri = uri;\nrx.EnabledChannels = [1 2 3 4];\nrx.MainNCOFrequencies = ones(1,4)*550e6; %NCO Frequency\nrx.SamplesPerFrame = 2^12; %Number Of Samples To Capture: 4096\nrx.kernelBuffersCount = 1; %Number Of Buffers To Subsequently Capture\nrx.EnablePFIRs = true; %MxFE pFIR Configuration; false: Don't Use pFIRs, true: Use pFIRs\ndata = rx(); %Initialize The Rx System; Grab The Rx Data Into 'data' Matrix\n\n% Setup ADAR1000EVAL1Z in RX Mode\nsray = adi.Stingray;\nsray.uri = uri;\nsray.Frequency = 10e9;\nsray.Mode(:) = {'Rx'}; %set mode, 'Rx', 'Tx, 'Disabled'\nsray.RxAttn(:) = 1; %1: Attenuation Off, 0: Attenuation On\nsray.SteerRx(0,0); %Broadside\nsray.RxGain(:) = 127; %127: Highest Gain, 0: Lowest Gain, Decimal Value\nsray.LatchRxSettings; %Latch SPI settings to devices\nsray(); %constructor to write properties to hardware\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on lines 10 and 21. Therefore, any properties that are set or defined before these lines are not applied or updated on the hardware until after these lines. However, after lines 10 and 21 have executed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by lines 10 and 21 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release AD9081 object\nsray.release(); % Release Stingray Object\n</code></pre></p> <p>For more details on documentation related to using the AD9081 high-speed converter, see this page.</p>"},{"location":"support/","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"_pages/","title":"Index","text":"<p>{% include 'header.tmpl' %}</p> <p> <p></p> <p>ADI maintains a set of tools to model, interface, and target with ADI's beamformers and microwave devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release ADALM-PHASER NA Yes No ADI (2021b) Stingray ZCU102 Yes No ADI (2021b)"},{"location":"_pages/examples/","title":"Examples","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/examples/#examples","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"_pages/install/","title":"Install","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/install/#installation","title":"Installation","text":""},{"location":"_pages/install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.</p>"},{"location":"_pages/install/#simulation-models","title":"Simulation Models","text":"<p>The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks:</p> <ul> <li>DSP System Toolbox</li> <li>Signal Processing Toolbox</li> <li>(Optional) Simulink</li> </ul>"},{"location":"_pages/install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox\u2122</li> </ul> </li> </ul>"},{"location":"_pages/install/#rf-and-microwave-toolbox-install","title":"RF and Microwave Toolbox Install","text":"<p>The RF and Microwave Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing RF and Microwave Toolbox check the Release Page to check for the latest supported version of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"_pages/install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab:</p> <p></p> <p>Search for the toolbox:</p> <p></p> <p>Select RF and Microwave Toolbox from results:</p> <p></p> <p>Select add:</p> <p></p>"},{"location":"_pages/streaming/","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all libiio-based systems.</p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"_pages/streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up an AD9361 receiver and the Stingray class in an X-band development kit using an Ethernet/IP backend where the address of the target system is 192.168.2.1: <pre><code>uri = 'ip:192.168.1.211';\n\nrx = adi.AD9081.Rx;\nrx.uri = uri;\nrx.EnabledChannels = [1 2 3 4];\nrx.MainNCOFrequencies = ones(1,4)*550e6; %NCO Frequency\nrx.SamplesPerFrame = 2^12; %Number Of Samples To Capture: 4096\nrx.kernelBuffersCount = 1; %Number Of Buffers To Subsequently Capture\nrx.EnablePFIRs = true; %MxFE pFIR Configuration; false: Don't Use pFIRs, true: Use pFIRs\ndata = rx(); %Initialize The Rx System; Grab The Rx Data Into 'data' Matrix\n\n% Setup ADAR1000EVAL1Z in RX Mode\nsray = adi.Stingray;\nsray.uri = uri;\nsray.Frequency = 10e9;\nsray.Mode(:) = {'Rx'}; %set mode, 'Rx', 'Tx, 'Disabled'\nsray.RxAttn(:) = 1; %1: Attenuation Off, 0: Attenuation On\nsray.SteerRx(0,0); %Broadside\nsray.RxGain(:) = 127; %127: Highest Gain, 0: Lowest Gain, Decimal Value\nsray.LatchRxSettings; %Latch SPI settings to devices\nsray(); %constructor to write properties to hardware\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on lines 10 and 21. Therefore, any properties that are set or defined before these lines are not applied or updated on the hardware until after these lines. However, after lines 10 and 21 have executed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by lines 10 and 21 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release AD9081 object\nsray.release(); % Release Stingray Object\n</code></pre></p> <p>For more details on documentation related to using the AD9081 high-speed converter, see this page.</p>"},{"location":"_pages/support/","title":"Support","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/support/#support","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"sysobjects/adi.Phaser/","title":"adi.Phaser","text":"The adi.Phaser system object is an API to control the    ADALM-PHASER X/Ku Band Beamforming Developer Platform.     rx = adi.Phaser;    rx = adi.Phaser('uri','ip:ip:192.168.2.1'); Stingray X/Ku Band Beamforming Developer Platform Wiki Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.Phaser\ndev = adi.Phaser(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnablePLL + <p>Enable onboard PLL which is the main LO source. This controls V_CTRL_1</p> EnableTxPLL + <p>Enable PLL to feed the Tx LO. This controls V_CTRL_2</p> NumADAR1000s + <p></p> Mode + <p>Mode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of value 'Rx', 'Tx', or 'disabled' to set the modes.</p> LNABiasOutEnable + <p>Enable output of LNA bias DAC. LNABiasOutEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOn + <p>External Bias for External LNAs. LNABiasOn is an array where each element addresses individual ADAR1000's.</p> BeamMemEnable + <p>Enable beam memory. BeamMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACEnable + <p>Enable PA and LNA bias DACs. BiasDACEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACMode + <p>External Amplifier Bias Control. BiasDACMode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'On' or 'Off' to set the modes.</p> BiasMemEnable + <p>Enable bias memory. BiasMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonMemEnable + <p>CommonMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonRxBeamState + <p>Static Rx Beam Position Load. CommonRxBeamState is an array where each element addresses individual ADAR1000's.</p> CommonTxBeamState + <p>Static Tx Beam Position Load. CommonTxBeamState is an array where each element addresses individual ADAR1000's.</p> ExternalTRPin + <p>Select Tx/Rx output driver. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'Pos' or 'Neg' to set the modes.</p> ExternalTRPolarity + <p>Controls Sense of Tx/Rx Switch Driver Output. ExternalTRPolarity is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOff + <p>External Bias for External LNAs. LNABiasOff is an array where each element addresses individual ADAR1000's.</p> PolState + <p>Control for External Polarity Switch Drivers. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> PolSwitchEnable + <p>Enables Switch Driver for External Polarization Switch. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxLNABiasCurrent + <p>Set LNA bias current. RxLNABiasCurrent is an array where each element addresses individual ADAR1000's.</p> RxLNAEnable + <p>Enables Rx LNA. RxLNAEnable is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> RxToTxDelay1 + <p>LNA Bias off to TR Switch Delay. RxToTxDelay1 is an array where each element addresses individual ADAR1000's.</p> RxToTxDelay2 + <p>TR Switch to PA Bias on Delay. RxToTxDelay2 is an array where each element addresses individual ADAR1000's.</p> RxVGAEnable + <p>Enable Rx Channel VGAs. RxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxVGABiasCurrentVM + <p>Apply Rx bias current. RxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> RxVMEnable + <p>Enable Rx Channel Vector Modulators. RxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> SequencerEnable + <p>Enable sequencer. Sequencer is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TRSwitchEnable + <p>Enables Switch Driver for External Tx/Rx Switch. TRSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxPABiasCurrent + <p>Set Tx driver bias current. TxPABiasCurrent is an array where each element addresses individual ADAR1000's.</p> TxPAEnable + <p>Enables the Tx channel drivers. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> TxToRxDelay1 + <p>PA Bias off to TR Switch Delay. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.</p> TxToRxDelay2 + <p>TR Switch to LNA Bias on Delay. TxToRxDelay2 is an array where each element addresses individual ADAR1000's.</p> TxVGAEnable + <p>Enable Tx Channel VGAs. TxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxVGABiasCurrentVM + <p>Apply Tx bias current. TxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> TxVMEnable + <p>Enable Tx Channel Vector Modulators. TxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxRxSwitchControl + <p>Set source of control for Rx and Tx switching. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'spi' or 'external' to set the modes.</p> DetectorEnable + <p>DetectorEnable is an array where each element addresses each channel of each ADAR1000.</p> DetectorPower + <p>DetectorPower is an array where each element addresses each channel of each ADAR1000.</p> PABiasOff + <p>Apply bias off to external PA. PABiasOff is an array where each element addresses each channel of each ADAR1000.</p> PABiasOn + <p>Apply bias on to external PA. PABiasOn is an array where each element addresses each channel of each ADAR1000.</p> RxAttn + <p>Attenuate Rx channels. RxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> RxBeamState + <p>Load Rx Position. RxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxPowerDown + <p>Power down Rx channels. RxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> RxGain + <p>Apply gain to Rx channels. RxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> RxPhase + <p>Apply phase to Rx channels. RxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxAttn + <p>Attenuate Tx channels. TxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> TxBeamState + <p>Load Tx Position. TxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxPowerDown + <p>Power down Tx channels. TxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> TxGain + <p>Apply gain to Tx channels. TxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> TxPhase + <p>Apply phase to Tx channels. TxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxSequencerStart + <p>RxSequencerStart Rx Sequencer Start RxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> RxSequencerStop + <p>RxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStart + <p>TxSequencerStart Tx Sequencer Start TxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStop + <p>TxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> Temp + <p>Get temperature of X-band Development Platform.</p> TargetFrequency + <p>ADAR1000 target frequency</p> ElementSpacing + <p>ADAR1000 element spacing</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.Phaser/uri is inherited from superclass matlabshared.libiio.base</p> channelCount + <p>Number of enabled channelsHelp for adi.Phaser/channelCount is inherited from superclass matlabshared.libiio.base</p> DataTimeout + <p>Timeout for I/O operations (in seconds) 0 = non-blocking (or default context timeout) Inf = infiniteHelp for adi.Phaser/DataTimeout is inherited from superclass matlabshared.libiio.base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> Frequency + <p>Set output frequency of synthesizer in Hz. When the synthesizer is ramping this is the start frequencyHelp for adi.Phaser/Frequency is inherited from superclass adi.internal.ADF4159</p> FrequencyDeviationRange + <p>Set upper bound on frequency ramp from Frequency property in Hz. This is only applicable when RampMode is not set to \"disabled\"Help for adi.Phaser/FrequencyDeviationRange is inherited from superclass adi.internal.ADF4159</p> FrequencyDeviationStep + <p>Set step size in Hz of synthesizer ramp. This is only applicable when RampMode is not set to \"disabled\".Help for adi.Phaser/FrequencyDeviationStep is inherited from superclass adi.internal.ADF4159</p> FrequencyDeviationTime + <p>Set time in uSeconds to reach ramp peak value. This is only applicable when RampMode is not set to \"disabled\"Help for adi.Phaser/FrequencyDeviationTime is inherited from superclass adi.internal.ADF4159</p> RampMode + <p>Set ramp waveform. Options are: - \"disabled\" - \"continuous_sawtooth\" - \"continuous_triangular\" - \"single_sawtooth_burst\" - \"single_ramp_burst\"Help for adi.Phaser/RampMode is inherited from superclass adi.internal.ADF4159</p> Powerdown + <p>When true output will be disabled. Writing to this value will also update all settings of deviceHelp for adi.Phaser/Powerdown is inherited from superclass adi.internal.ADF4159</p> DelayStartWord + <p>Set start delay of each ramp in PFD or PFD*CLK1 clock cycles. This is a 12-bit numberHelp for adi.Phaser/DelayStartWord is inherited from superclass adi.internal.ADF4159</p> DelayClockSource + <p>Set clock use to determine ramp delay. Options are: - \"PFD\" - \"PFD*CLK1\"Help for adi.Phaser/DelayClockSource is inherited from superclass adi.internal.ADF4159</p> DelayStartEnable + <p>Enable delaying of ramp signal at start of first ramp generationHelp for adi.Phaser/DelayStartEnable is inherited from superclass adi.internal.ADF4159</p> RampDelayEnable + <p>Enable delaying of ramp signal at start of each ramp generationHelp for adi.Phaser/RampDelayEnable is inherited from superclass adi.internal.ADF4159</p> TriggerDelayEnable + <p>Enable ramp start delay when controlled by external triggerHelp for adi.Phaser/TriggerDelayEnable is inherited from superclass adi.internal.ADF4159</p> TriggerEnable + <p>Allow for use of external trigger on TX Data pin to start rampHelp for adi.Phaser/TriggerEnable is inherited from superclass adi.internal.ADF4159</p> SingleFullTriangleEnable + <p>Enable sending of single full triangular wave. This is applicable when RampMode is in \"single_ramp_burst\"Help for adi.Phaser/SingleFullTriangleEnable is inherited from superclass adi.internal.ADF4159</p> BurstCount + <p>Configure number of bursts in TDD controllerHelp for adi.Phaser/BurstCount is inherited from superclass adi.internal.AXICoreTDD</p> CounterInt + <p>Configure TDD internal counter start valueHelp for adi.Phaser/CounterInt is inherited from superclass adi.internal.AXICoreTDD</p> DMAGateingMode + <p>Configure TDD DMA gate 0 - none, 1 - rx_only, 2 - tx_only, 3 - rx_txHelp for adi.Phaser/DMAGateingMode is inherited from superclass adi.internal.AXICoreTDD</p> Enable + <p>Enable or disable the TDD engineHelp for adi.Phaser/Enable is inherited from superclass adi.internal.AXICoreTDD</p> EnableMode + <p>Configure TDD controller RX/TX mode 1 - rx_only, 2 - tx_only, 3 - rx_txHelp for adi.Phaser/EnableMode is inherited from superclass adi.internal.AXICoreTDD</p> FrameLength + <p>TDD Frame LengthHelp for adi.Phaser/FrameLength is inherited from superclass adi.internal.AXICoreTDD</p> Secondary + <p>Enable secondary times. Allows one signal to go high twice at two times within a single frame.Help for adi.Phaser/Secondary is inherited from superclass adi.internal.AXICoreTDD</p> SyncTerminalType + <p>Sync Terminal TypeHelp for adi.Phaser/SyncTerminalType is inherited from superclass adi.internal.AXICoreTDD</p> TxDPoff + <p>TDD: TX DMA port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Phaser/TxDPoff is inherited from superclass adi.internal.AXICoreTDD</p> TxDPon + <p>TDD: TX DMA port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Phaser/TxDPon is inherited from superclass adi.internal.AXICoreTDD</p> TxOff + <p>TDD: TX RF port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Phaser/TxOff is inherited from superclass adi.internal.AXICoreTDD</p> TxOn + <p>TDD: TX RF port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Phaser/TxOn is inherited from superclass adi.internal.AXICoreTDD</p> TxVCOoff + <p>TDD: TX VCO port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Phaser/TxVCOoff is inherited from superclass adi.internal.AXICoreTDD</p> TxVCOon + <p>TDD: TX VCO port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Phaser/TxVCOon is inherited from superclass adi.internal.AXICoreTDD</p> RxDPoff + <p>TDD: RX DMA port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Phaser/RxDPoff is inherited from superclass adi.internal.AXICoreTDD</p> RxDPon + <p>TDD: RX DMA port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Phaser/RxDPon is inherited from superclass adi.internal.AXICoreTDD</p> RxOff + <p>TDD: RX RF port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Phaser/RxOff is inherited from superclass adi.internal.AXICoreTDD</p> RxOn + <p>TDD: RX RF port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Phaser/RxOn is inherited from superclass adi.internal.AXICoreTDD</p> RxVCOoff + <p>TDD: RX VCO port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Phaser/RxVCOoff is inherited from superclass adi.internal.AXICoreTDD</p> RxVCOon + <p>TDD: RX VCO port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Phaser/RxVCOon is inherited from superclass adi.internal.AXICoreTDD</p> Example Usage <pre><code>%% Configure device\ntx = adi.Phaser;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.Stingray/","title":"adi.Stingray","text":"The adi.Stingray system object is an API to control the    Stingray X/Ku Band Beamforming Developer Platform.     rx = adi.Stingray;    rx = adi.Stingray('uri','ip:ip:192.168.2.1'); Stingray X/Ku Band Beamforming Developer Platform Wiki Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.Stingray\ndev = adi.Stingray(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. NumADAR1000s + <p></p> Mode + <p>Mode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of value 'Rx', 'Tx', or 'disabled' to set the modes.</p> LNABiasOutEnable + <p>Enable output of LNA bias DAC. LNABiasOutEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOn + <p>External Bias for External LNAs. LNABiasOn is an array where each element addresses individual ADAR1000's.</p> BeamMemEnable + <p>Enable beam memory. BeamMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACEnable + <p>Enable PA and LNA bias DACs. BiasDACEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> BiasDACMode + <p>External Amplifier Bias Control. BiasDACMode is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'On' or 'Off' to set the modes.</p> BiasMemEnable + <p>Enable bias memory. BiasMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonMemEnable + <p>CommonMemEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> CommonRxBeamState + <p>Static Rx Beam Position Load. CommonRxBeamState is an array where each element addresses individual ADAR1000's.</p> CommonTxBeamState + <p>Static Tx Beam Position Load. CommonTxBeamState is an array where each element addresses individual ADAR1000's.</p> ExternalTRPin + <p>Select Tx/Rx output driver. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'Pos' or 'Neg' to set the modes.</p> ExternalTRPolarity + <p>Controls Sense of Tx/Rx Switch Driver Output. ExternalTRPolarity is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> LNABiasOff + <p>External Bias for External LNAs. LNABiasOff is an array where each element addresses individual ADAR1000's.</p> PolState + <p>Control for External Polarity Switch Drivers. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> PolSwitchEnable + <p>Enables Switch Driver for External Polarization Switch. PolSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxLNABiasCurrent + <p>Set LNA bias current. RxLNABiasCurrent is an array where each element addresses individual ADAR1000's.</p> RxLNAEnable + <p>Enables Rx LNA. RxLNAEnable is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> RxToTxDelay1 + <p>LNA Bias off to TR Switch Delay. RxToTxDelay1 is an array where each element addresses individual ADAR1000's.</p> RxToTxDelay2 + <p>TR Switch to PA Bias on Delay. RxToTxDelay2 is an array where each element addresses individual ADAR1000's.</p> RxVGAEnable + <p>Enable Rx Channel VGAs. RxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> RxVGABiasCurrentVM + <p>Apply Rx bias current. RxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> RxVMEnable + <p>Enable Rx Channel Vector Modulators. RxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> SequencerEnable + <p>Enable sequencer. Sequencer is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TRSwitchEnable + <p>Enables Switch Driver for External Tx/Rx Switch. TRSwitchEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxPABiasCurrent + <p>Set Tx driver bias current. TxPABiasCurrent is an array where each element addresses individual ADAR1000's.</p> TxPAEnable + <p>Enables the Tx channel drivers. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.  Each element must be a logical true (to enable) or false (to not enable).</p> TxToRxDelay1 + <p>PA Bias off to TR Switch Delay. TxToRxDelay1 is an array where each element addresses individual ADAR1000's.</p> TxToRxDelay2 + <p>TR Switch to LNA Bias on Delay. TxToRxDelay2 is an array where each element addresses individual ADAR1000's.</p> TxVGAEnable + <p>Enable Tx Channel VGAs. TxVGAEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxVGABiasCurrentVM + <p>Apply Tx bias current. TxVGABiasCurrentVM is an array where each element addresses individual ADAR1000's.</p> TxVMEnable + <p>Enable Tx Channel Vector Modulators. TxVMEnable is an array where each element addresses individual ADAR1000's. Each element must be a logical true (to enable) or false (to not enable).</p> TxRxSwitchControl + <p>Set source of control for Rx and Tx switching. TxRxSwitchControl is a cellarray where each element addresses individual ADAR1000's. Each cell must contain a string of values 'spi' or 'external' to set the modes.</p> DetectorEnable + <p>DetectorEnable is an array where each element addresses each channel of each ADAR1000.</p> DetectorPower + <p>DetectorPower is an array where each element addresses each channel of each ADAR1000.</p> PABiasOff + <p>Apply bias off to external PA. PABiasOff is an array where each element addresses each channel of each ADAR1000.</p> PABiasOn + <p>Apply bias on to external PA. PABiasOn is an array where each element addresses each channel of each ADAR1000.</p> RxAttn + <p>Attenuate Rx channels. RxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> RxBeamState + <p>Load Rx Position. RxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxPowerDown + <p>Power down Rx channels. RxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> RxGain + <p>Apply gain to Rx channels. RxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> RxPhase + <p>Apply phase to Rx channels. RxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxAttn + <p>Attenuate Tx channels. TxAttn is an array where each element addresses each channel of each ADAR1000. Each element must be a logical true (to attenuate) or false (to not attenuate).</p> TxBeamState + <p>Load Tx Position. TxBeamState is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> TxPowerDown + <p>Power down Tx channels. TxPowerDown is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false (to power up) or true (to power down).</p> TxGain + <p>Apply gain to Tx channels. TxGain is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 127.</p> TxPhase + <p>Apply phase to Tx channels. TxPhase is an array where each element addresses each channel of each ADAR1000. Each element must be a value between 0 and 360.</p> RxSequencerStart + <p>RxSequencerStart Rx Sequencer Start RxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> RxSequencerStop + <p>RxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStart + <p>TxSequencerStart Tx Sequencer Start TxSequencerStart is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> TxSequencerStop + <p>TxSequencerStop is a logical array where each element addresses each channel of each ADAR1000. Each element must be a logical false or true.</p> Temp + <p>Get temperature of X-band Development Platform.</p> TargetFrequency + <p>ADAR1000 target frequency</p> ElementSpacing + <p>ADAR1000 element spacing</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.Stingray/uri is inherited from superclass matlabshared.libiio.base</p> channelCount + <p>Number of enabled channelsHelp for adi.Stingray/channelCount is inherited from superclass matlabshared.libiio.base</p> DataTimeout + <p>Timeout for I/O operations (in seconds) 0 = non-blocking (or default context timeout) Inf = infiniteHelp for adi.Stingray/DataTimeout is inherited from superclass matlabshared.libiio.base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> PowerUpDown + <p>Pulse to sequence the first RF power rails in ADAR1000-EVAL1Z board power treeHelp for adi.Stingray/PowerUpDown is inherited from superclass adi.internal.StingrayControl</p> Ctrl5V + <p>Pulse +5V in ADAR1000-EVAL1Z board power treeHelp for adi.Stingray/Ctrl5V is inherited from superclass adi.internal.StingrayControl</p> PAOn + <p>Enable/disable PA in ADAR1000-EVAL1Z board power treeHelp for adi.Stingray/PAOn is inherited from superclass adi.internal.StingrayControl</p> TXRX0 + <p>Select Channel A for XUD1A Up and Down converter Usage: Channel A in Tx Mode - Set TXRX0 to 0, RxGainMode to 0 Channel A in Rx Low Gain Mode - Set TXRX0 to 1, RxGainMode to 0 Channel A in Rx High Gain Mode - Set TXRX0 to 1, RxGainMode to 1Help for adi.Stingray/TXRX0 is inherited from superclass adi.internal.XUD1aControl</p> TXRX1 + <p>Select Channel B for XUD1A Up and Down converter Usage: Channel B in Tx Mode - Set TXRX1 to 0, RxGainMode to 0 Channel B in Rx Low Gain Mode - Set TXRX1 to 1, RxGainMode to 0 Channel B in Rx High Gain Mode - Set TXRX1 to 1, RxGainMode to 1Help for adi.Stingray/TXRX1 is inherited from superclass adi.internal.XUD1aControl</p> TXRX2 + <p>Select Channel C for XUD1A Up and Down converter Usage: Channel C in Tx Mode - Set TXRX2 to 0, RxGainMode to 0 Channel C in Rx Low Gain Mode - Set TXRX2 to 1, RxGainMode to 0 Channel C in Rx High Gain Mode - Set TXRX2 to 1, RxGainMode to 1Help for adi.Stingray/TXRX2 is inherited from superclass adi.internal.XUD1aControl</p> TXRX3 + <p>Select Channel D for XUD1A Up and Down converter Usage: Channel D in Tx Mode - Set TXRX3 to 0, RxGainMode to 0 Channel D in Rx Low Gain Mode - Set TXRX3 to 1, RxGainMode to 0 Channel D in Rx High Gain Mode - Set TXRX3 to 1, RxGainMode to 1Help for adi.Stingray/TXRX3 is inherited from superclass adi.internal.XUD1aControl</p> PllOutputSel + <p>Configure ADF4371 output frequency 1: 8-16 GHz 0: 16-32 GHzHelp for adi.Stingray/PllOutputSel is inherited from superclass adi.internal.XUD1aControl</p> RxGainMode + <p>For usage, see usage of TXRX[0-3]Help for adi.Stingray/RxGainMode is inherited from superclass adi.internal.XUD1aControl</p> ADF4371Name + <p>Configure programmable divider for ADF4371 Options: 'RF16x' or 'RF32x'Help for adi.Stingray/ADF4371Name is inherited from superclass adi.internal.ADF4371</p> ADF4371Frequency + <p>Configure ADF4371 output frequency Allowed range: 'RF16x': &gt;= 8GHz, &lt;= 16 GHz 'RF32x': &gt;= 16GHz, &lt;= 32 GHzHelp for adi.Stingray/ADF4371Frequency is inherited from superclass adi.internal.ADF4371</p> ADF4371Phase + <p>Configure ADF4371 output phase in milli-degrees Range: 0-359999Help for adi.Stingray/ADF4371Phase is inherited from superclass adi.internal.ADF4371</p> MUXOutEnable + <p>Enable output multiplexer on the ADF4371Help for adi.Stingray/MUXOutEnable is inherited from superclass adi.internal.ADF4371</p> BurstCount + <p>Configure number of bursts in TDD controllerHelp for adi.Stingray/BurstCount is inherited from superclass adi.internal.AXICoreTDD</p> CounterInt + <p>Configure TDD internal counter start valueHelp for adi.Stingray/CounterInt is inherited from superclass adi.internal.AXICoreTDD</p> DMAGateingMode + <p>Configure TDD DMA gate 0 - none, 1 - rx_only, 2 - tx_only, 3 - rx_txHelp for adi.Stingray/DMAGateingMode is inherited from superclass adi.internal.AXICoreTDD</p> Enable + <p>Enable or disable the TDD engineHelp for adi.Stingray/Enable is inherited from superclass adi.internal.AXICoreTDD</p> EnableMode + <p>Configure TDD controller RX/TX mode 1 - rx_only, 2 - tx_only, 3 - rx_txHelp for adi.Stingray/EnableMode is inherited from superclass adi.internal.AXICoreTDD</p> FrameLength + <p>TDD Frame LengthHelp for adi.Stingray/FrameLength is inherited from superclass adi.internal.AXICoreTDD</p> Secondary + <p>Enable secondary times. Allows one signal to go high twice at two times within a single frame.Help for adi.Stingray/Secondary is inherited from superclass adi.internal.AXICoreTDD</p> SyncTerminalType + <p>Sync Terminal TypeHelp for adi.Stingray/SyncTerminalType is inherited from superclass adi.internal.AXICoreTDD</p> TxDPoff + <p>TDD: TX DMA port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Stingray/TxDPoff is inherited from superclass adi.internal.AXICoreTDD</p> TxDPon + <p>TDD: TX DMA port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Stingray/TxDPon is inherited from superclass adi.internal.AXICoreTDD</p> TxOff + <p>TDD: TX RF port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Stingray/TxOff is inherited from superclass adi.internal.AXICoreTDD</p> TxOn + <p>TDD: TX RF port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Stingray/TxOn is inherited from superclass adi.internal.AXICoreTDD</p> TxVCOoff + <p>TDD: TX VCO port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Stingray/TxVCOoff is inherited from superclass adi.internal.AXICoreTDD</p> TxVCOon + <p>TDD: TX VCO port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Stingray/TxVCOon is inherited from superclass adi.internal.AXICoreTDD</p> RxDPoff + <p>TDD: RX DMA port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Stingray/RxDPoff is inherited from superclass adi.internal.AXICoreTDD</p> RxDPon + <p>TDD: RX DMA port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Stingray/RxDPon is inherited from superclass adi.internal.AXICoreTDD</p> RxOff + <p>TDD: RX RF port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Stingray/RxOff is inherited from superclass adi.internal.AXICoreTDD</p> RxOn + <p>TDD: RX RF port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Stingray/RxOn is inherited from superclass adi.internal.AXICoreTDD</p> RxVCOoff + <p>TDD: RX VCO port timing parameters in ms. Format [primary_off secondary_off]Help for adi.Stingray/RxVCOoff is inherited from superclass adi.internal.AXICoreTDD</p> RxVCOon + <p>TDD: RX VCO port timing parameters in ms. Format [primary_on secondary_on]Help for adi.Stingray/RxVCOon is inherited from superclass adi.internal.AXICoreTDD</p> LTC2314RFPower + <p>RF power level measured from on-board RF detector, LTC2314Help for adi.Stingray/LTC2314RFPower is inherited from superclass adi.internal.LTC2314</p> Example Usage <pre><code>%% Configure device\ntx = adi.Stingray;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"}]}